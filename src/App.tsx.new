// File: src/App.tsx
/**
 * ChatCast Studio — PRF-Compliant Frontend (2025-10-22)
 * Dependencies are auto-managed via ./services/envSetup.js
 * Features:
 *  - Auto-detects and exports missing API keys using envSetup.js
 *  - Fetches /api/voices for user selection
 *  - Handles chat log uploads (.txt/.json/.zip)
 *  - Streams TTS audio from backend
 *  - Provides direct audio download
 *  - Integrated with PodcastSettings, AnalysisSummary, ScriptPreview
 */

import './services/envSetup.js'; // ✅ auto-manages dependencies and environment keys

import React, { useState, useEffect, useCallback } from 'react';
import PodcastSettings from './components/PodcastSettings';
import { AnalysisSummary } from './components/AnalysisSummary';
import { ScriptPreview } from './components/ScriptPreview';
import { Loader } from './components/Loader';
import { ErrorBoundary } from './components/ErrorBoundary';
import { FileUpload } from './components/FileUpload';
import type { PodcastConfig, AnalysisResult, GeneratedScript, ChatMessage, VoiceOption } from './types';
import { parseTextContent } from './services/parserService';
import { analyzeChat, analyzeScript } from './services/analysisService';
import { generateScriptFromChat } from './services/geminiService';
import { generatePodcastWithNotebookLM } from './services/notebooklmService';

const defaultConfig: PodcastConfig = {
  style: 'informative',
  technicality: 'medium',
  voiceMapping: new Map(),
  includeMusic: true,
  includeSfx: true,
};

const App: React.FC = () => {
  const [config, setConfig] = useState<PodcastConfig>(defaultConfig);
  const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
  const [script, setScript] = useState<GeneratedScript | null>(null);
  const [analysis, setAnalysis] = useState<AnalysisResult | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [audioUrl, setAudioUrl] = useState<string | null>(null);
  const [voices, setVoices] = useState<VoiceOption[]>([]);
  const [selectedVoice, setSelectedVoice] = useState<string>('en');

  // -------------------------------
  // Fetch available voices from backend
  // -------------------------------
  useEffect(() => {
    async function fetchVoices() {
      try {
        const resp = await fetch('/api/voices');
        if (!resp.ok) throw new Error('Failed to fetch voices');
        const data: VoiceOption[] = await resp.json();
        setVoices(data);
        if (data.length) setSelectedVoice(data[0].name);
      } catch (err) {
        console.error('Voice fetch error:', err);
        setVoices([{ name: 'en', lang: 'English' }]); // fallback
      }
    }
    fetchVoices();
  }, []);

  // -------------------------------
  // Update Podcast settings callback
  // -------------------------------
  const handleSettingsChange = useCallback((settings: any) => {
    setConfig(prev => ({
      ...prev,
      style: settings.narrationStyle || prev.style,
      technicality: settings.abstractionLevel || prev.technicality,
      tone: settings.tone || prev.tone,
      summaryLength: settings.summaryLength || prev.summaryLength,
    }));
  }, []);

  // -------------------------------
  // Handle chat input (file or text)
  // -------------------------------
  const handleChatInput = async (file?: File, pastedText?: string) => {
    if (!file && !pastedText) return;
    setLoading(true); setError(null); setAudioUrl(null);
    try {
      const content = file ? await file.text() : pastedText!;
      const processed = await parseTextContent(content);

      if (processed.messages) {
        setChatMessages(processed.messages);
        setAnalysis(analyzeChat(processed.messages));
        setScript(null);
        try {
          // Gemini primary
          const generated = await generateScriptFromChat(processed.messages, config as any);
          setScript(generated);
          setAnalysis(analyzeScript(generated));
        } catch (gemErr) {
          console.warn('Gemini failed, switching to NotebookLM...', gemErr);
          try {
            const notebookOutput = await generatePodcastWithNotebookLM(processed.messages, config);
            setScript({ content: notebookOutput.scriptText } as any);
            setAnalysis(analyzeScript({ content: notebookOutput.scriptText }));
            if (notebookOutput.audioUrl) setAudioUrl(notebookOutput.audioUrl);
          } catch (nbErr) {
            console.error('NotebookLM generation failed', nbErr);
            setError('Both Gemini and NotebookLM generation failed.');
          }
        }
      } else if (processed.script) {
        setScript(processed.script);
        setAnalysis(analyzeScript(processed.script));
        setChatMessages([]);
      }
    } catch (err) {
      console.error('Failed to process chat input', err);
      setError('Failed to process chat or script.');
    } finally {
      setLoading(false);
    }
  };

  // -------------------------------
  // Trigger backend TTS for generated script
  // -------------------------------
  const handleGenerateAudio = async () => {
    if (!script?.content) return;
    setLoading(true);
    try {
      const formData = new FormData();
      formData.append('text', script.content);
      formData.append('voice', selectedVoice);

      const resp = await fetch('/api/synthesize', { method: 'POST', body: formData });
      if (!resp.ok) throw new Error('TTS request failed');

      const data = await resp.json();
      setAudioUrl(data.url); // set for <audio> streaming
    } catch (err) {
      console.error('TTS error:', err);
      setError('Audio generation failed.');
    } finally {
      setLoading(false);
    }
  };

  // -------------------------------
  // Reset project
  // -------------------------------
  const handleNewProject = () => {
    setChatMessages([]); setScript(null); setAnalysis(null); setConfig(defaultConfig);
    setError(null); setAudioUrl(null);
  };

  return (
    <ErrorBoundary>
      <div className="app container mx-auto p-6"
           style={{ backgroundColor: 'var(--bg-dark-bg)', color: 'var(--text-dark-text)' }}>
        <h1 className="text-3xl font-bold mb-6">ChatCast Studio</h1>

        {/* Podcast settings panel */}
        <PodcastSettings onChange={handleSettingsChange} analysis={analysis} />

        {/* Voice selection dropdown */}
        <div className="my-4">
          <label className="block mb-1 font-semibold">Select TTS Voice:</label>
          <select
            value={selectedVoice}
            onChange={(e) => setSelectedVoice(e.target.value)}
            className="border p-1 rounded"
          >
            {voices.map(v => <option key={v.name} value={v.name}>{v.lang}</option>)}
          </select>
        </div>

        {/* File upload / paste input */}
        <div className="my-4">
          <FileUpload
            onFileSelected={handleChatInput}
            onTextPasted={(text) => handleChatInput(undefined, text)}
          />
        </div>

        {/* Loading and error indicators */}
        {loading && <Loader message="Processing chat/script/audio..." />}
        {error && <div className="p-2 rounded mb-2" style={{ backgroundColor: 'red', color: 'white' }}>{error}</div>}

        {/* Analysis summary */}
        {analysis && !loading && <AnalysisSummary analysis={analysis} />}

        {/* Script preview + TTS controls */}
        {script && !loading && (
          <div className="mt-4">
            <ScriptPreview
              script={script}
              config={config}
              analysis={analysis || { speakers: [], messageCount: 0, wordCount: 0, estimatedDurationMinutes: 0 }}
              onNewScript={handleNewProject}
            />
            <div className="mt-2">
              <button
                className="px-4 py-2 bg-blue-600 text-white rounded mr-2"
                onClick={handleGenerateAudio}
              >
                Generate Audio
              </button>
              {audioUrl && (
                <div className="mt-2">
                  <audio controls src={audioUrl} style={{ width: '100%' }} />
                  <a href={audioUrl} download className="block mt-1 text-sm text-blue-300">
                    Download MP3
                  </a>
                </div>
              )}
            </div>
          </div>
        )}

        {/* Initial prompt */}
        {!loading && !script && !analysis && !error && (
          <p style={{ color: 'var(--text-dark-text)', marginTop: '1rem' }}>
            Upload a chat log or paste text to begin generating your podcast script.
          </p>
        )}
      </div>
    </ErrorBoundary>
  );
};

export default App;
